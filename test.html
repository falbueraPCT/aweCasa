<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Calculate distance and bearing between two Latitude/Longitude points using haversine formula in JavaScript</title>
    <meta name="author" content="Chris Veness, www.movable-type.co.uk">
    <meta name="keywords" content="latitude longitude distance bearing points earth haversine great circle rhumb">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.css">
    <link rel="stylesheet" href="../css/base.css">
    <link rel="stylesheet" href="../css/eb-garamond/stylesheet.css">
    <link rel="stylesheet" href="../css/mtl.css">
    <style>
        input               { text-align: right; width: 6em; }
        input[type="radio"] { width: auto; vertical-align: baseline; }
        output              { color: #000099; font-weight: bold; }
        a                   { cursor: pointer; } /* for 'show map' */
        figcaption          { font-size: 0.8em; font-style: italic; text-align: center; }
        form ul.list        { list-style: inherit; } /* an actual list to appear within a form! */
        fieldset            { padding: 0 2em; }
        .inputs             { float: left; margin: 1em 2em 0 0; }
        .outputs            { margin: 1em 2em 0 0; }
        .map                { height: 480px; width: 480px; }
        .radicand           { border-top: solid 1px #cccccc; }
        .label              { color: #666666; font-style: italic; }
        td.formula          { line-height: 1; padding: 0.4em 0.1em; }
        aside {
            width: 21em;
        }
        code.prettyprint {
            display: block;
            font-size: 0.8em;
            line-height: 1;;
            margin-left: 2.5em;
            padding-bottom: 0.4em;
            text-indent: -2.5em;
        }

        @media screen and (max-width: 800px) {
            .formula { font-size: 0.9em; /* Times a bit strange on Android? */ }
            figure img { width: 120px; }
        }
    </style>
    <script defer src="//code.jquery.com/jquery-3.0.0.min.js"></script>
    <script defer src="//cdnjs.cloudflare.com/ajax/libs/es6-promise/4.0.5/es6-promise.auto.min.js"></script>
    <script defer src="//cdnjs.cloudflare.com/ajax/libs/fetch/0.11.1/fetch.min.js"></script>
    <script defer src="//cdnjs.cloudflare.com/ajax/libs/prettify/188.0.0/prettify.js">/* r224/r298 don't work! */</script>
    <script defer src="//cdnjs.cloudflare.com/ajax/libs/js-cookie/2.1.3/js.cookie.min.js">/* github.com/js-cookie/js-cookie */</script>
    <script defer src="//cdnjs.cloudflare.com/ajax/libs/qs/6.3.0/qs.min.js">/* github.com/ljharb/qs */</script>
    <script defer src="//maps.googleapis.com/maps/api/js"></script>
    <!--[if lt IE 9]> <script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script> <![endif]-->
    <script defer src="../js/mtl.js">/* MTL utils */</script>
    <script defer src="//cdn.rawgit.com/chrisveness/geodesy/v1.1.2/latlon-spherical.js">/* github.com/chrisveness/geodesy */</script>
    <script defer src="//cdn.rawgit.com/chrisveness/geodesy/v1.1.2/dms.js">/* github.com/chrisveness/geodesy */</script>
    <script>
        'use strict';
        var doc = document; doc.qrySel = doc.querySelector; doc.qrySelAll = doc.querySelectorAll; // shorthand

        var maps = { // note we have to track overlay items ourselves
            orthoDist: { map:null, geodesic:true,  overlay: { marker1:null, marker2:null, path:null } },
            orthoDest: { map:null, geodesic:true,  overlay: { marker1:null, marker2:null, path:null } },
            rhumbDist: { map:null, geodesic:false, overlay: { marker1:null, marker2:null, path:null } },
            rhumbDest: { map:null, geodesic:false, overlay: { marker1:null, marker2:null, path:null } }
        };

        document.addEventListener('DOMContentLoaded', function(event) {
            Dms.separator = '\u202f'; // narrow no-break space

            // has user made d/dms display preference?
            var degFmt = Cookies.get('latlon-degree-format') || 'dms';
            // show current preference
            doc.qrySel('#deg-format-'+degFmt).checked = true;

            // initialise maps
            var mapOptions = {
                zoom: 0,
                center: new google.maps.LatLng(0, 0),
                mapTypeId: google.maps.MapTypeId.HYBRID,
                mapTypeControlOptions: {
                    style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,
                },
                navigationControlOptions: {
                    style: google.maps.NavigationControlStyle.SMALL,
                },
                streetViewControl: false,
                scaleControl: true,
            };
            maps.orthoDist.map = new google.maps.Map(doc.qrySel('#map-ortho-dist-canvas'), mapOptions);
            maps.orthoDest.map = new google.maps.Map(doc.qrySel('#map-ortho-dest-canvas'), mapOptions);
            maps.rhumbDist.map = new google.maps.Map(doc.qrySel('#map-rhumb-dist-canvas'), mapOptions);
            maps.rhumbDest.map = new google.maps.Map(doc.qrySel('#map-rhumb-dest-canvas'), mapOptions);

            // ---- listeners for orthodrome distance / bearings / midpoint between two points

            // listener for updated values
            $('#ortho-dist input').change( function() {
                var lat1 = Dms.parseDMS($('#ortho-dist .lat1').val());
                var lon1 = Dms.parseDMS($('#ortho-dist .lon1').val());
                var lat2 = Dms.parseDMS($('#ortho-dist .lat2').val());
                var lon2 = Dms.parseDMS($('#ortho-dist .lon2').val());

                // calculate distance, bearing, mid-point
                var p1 = LatLon(lat1, lon1);
                var p2 = LatLon(lat2, lon2);
                var dist = p1.distanceTo(p2);
                var brng1 = p1.bearingTo(p2);
                var brng2 = p1.finalBearingTo(p2);
                var pMid = p1.midpointTo(p2);

                // display results
                var d = (dist/1000).toPrecision(4); // in km rounded to 4 significant figures
                $('#ortho-dist .result-dist').html(d>1 ? Number(d) : d); // avoid exponential notation
                $('#ortho-dist .result-brng1').html(Dms.toBrng(brng1, degFmt));
                $('#ortho-dist .result-brng2').html(Dms.toBrng(brng2, degFmt));
                $('#ortho-dist .result-midpt').html(pMid.toString(degFmt));

                // show path on map
                if ($('#map-ortho-dist-canvas').is(':visible')) {
                    drawPath(p1.lat, p1.lon, p2.lat, p2.lon, maps.orthoDist);
                }
            });
            $('#ortho-dist .lat1').trigger('change'); // initial calculation

            // listener for map toggle
            $('#ortho-dist .toggle-map a').click( function() {
                $('#ortho-dist .toggle-map').toggle(); // 'see on map' text
                $('#ortho-dist .map').toggle();        // the map itself

                $('#ortho-dist .lat1').trigger('change'); // to invoke drawPath()
            });

            // ---- listeners for orthodrome destination point from start point / bearing / distance

            // listener for updated values
            $('#ortho-dest input').change( function() {
                var lat1 = Dms.parseDMS($('#ortho-dest .lat1').val());
                var lon1 = Dms.parseDMS($('#ortho-dest .lon1').val());
                var dist = $('#ortho-dest .dist').val() * 1000; // convert km to metres
                var brng = Dms.parseDMS($('#ortho-dest .brng').val());

                // calculate destination point, final bearing
                var p1 = LatLon(lat1, lon1);
                var p2 = p1.destinationPoint(dist, brng);
                var brngFinal = p1.finalBearingTo(p2);

                // display results
                $('#ortho-dest .result-point').html(p2.toString(degFmt));
                $('#ortho-dest .result-brng').html(Dms.toBrng(brngFinal,degFmt));

                // show path on map
                if ($('#map-ortho-dest-canvas').is(':visible')) {
                    drawPath(p1.lat, p1.lon, p2.lat, p2.lon, maps.orthoDest);
                }
            });
            $('#ortho-dest .lat1').trigger('change'); // initial calculation

            // listener for map toggle
            $('#ortho-dest .toggle-map a').click( function() {
                $('#ortho-dest .toggle-map').toggle();
                $('#ortho-dest .map').toggle();

                $('#ortho-dest .lat1').trigger('change'); // to invoke drawPath()
            });

            // ---- listeners for intersection of two paths

            // listener for updated values
            $('#intersect input').change( function() {
                var lat1 = Dms.parseDMS($('#intersect .lat1').val());
                var lon1 = Dms.parseDMS($('#intersect .lon1').val());
                var lat2 = Dms.parseDMS($('#intersect .lat2').val());
                var lon2 = Dms.parseDMS($('#intersect .lon2').val());

                // calculate intersection point
                var p1 = LatLon(lat1, lon1);
                var p2 = LatLon(lat2, lon2);
                var brng1 = Dms.parseDMS($('#intersect .brng1').val());
                var brng2 = Dms.parseDMS($('#intersect .brng2').val());
                var pInt = LatLon.intersection(p1, brng1, p2, brng2);

                // display result
                $('#intersect .result-point').html(pInt==null ? '[ambiguous]' : pInt.toString(degFmt));
            });
            $('#intersect .lat1').trigger('change'); // initial calculation

            // ---- listeners for rhumb lines distance

            // listener for updated values
            $('#rhumb-dist input').change( function() {
                var lat1 = Dms.parseDMS($('#rhumb-dist .lat1').val());
                var lon1 = Dms.parseDMS($('#rhumb-dist .lon1').val());
                var lat2 = Dms.parseDMS($('#rhumb-dist .lat2').val());
                var lon2 = Dms.parseDMS($('#rhumb-dist .lon2').val());

                // calculate distance, bearing, mid-point
                var p1 = LatLon(lat1, lon1);
                var p2 = LatLon(lat2, lon2);
                var dist = p1.rhumbDistanceTo(p2);
                var brng = p1.rhumbBearingTo(p2);
                var pMid = p1.rhumbMidpointTo(p2);

                // display results
                var d = (dist/1000).toPrecision(4); // in km rounded to 4 significant figures
                $('#rhumb-dist .result-dist').html(d>1 ? Number(d) : d); // avoid exponential notation
                $('#rhumb-dist .result-brng').html(Dms.toBrng(brng, degFmt));
                $('#rhumb-dist .result-midpt').html(pMid.toString(degFmt));

                // show path on map
                if ($('#map-rhumb-dist-canvas').is(':visible')) {
                    drawPath(p1.lat, p1.lon, p2.lat, p2.lon, maps.rhumbDist);
                }
            });
            $('#rhumb-dist .lat1').trigger('change'); // initial calculation

            // listener for map toggle
            $('#rhumb-dist .toggle-map a').click( function() {
                $('#rhumb-dist .toggle-map').toggle();
                $('#rhumb-dist .map').toggle();

                $('#rhumb-dist .lat1').trigger('change'); // to invoke drawPath()
            });

            // ---- listeners for rhumb lines destination

            // listener for updated values
            $('#rhumb-dest input').change( function() {
                var lat1 = Dms.parseDMS($('#rhumb-dest .lat1').val());
                var lon1 = Dms.parseDMS($('#rhumb-dest .lon1').val());
                var brng = Dms.parseDMS($('#rhumb-dest .brng').val());
                var dist = $('#rhumb-dest .dist').val() * 1000; // convert km to metres

                // calculate destination point
                var p1 = LatLon(lat1, lon1);
                var p2 = p1.rhumbDestinationPoint(dist, brng);

                // display results
                $('#rhumb-dest .result-point').html(p2.toString(degFmt));

                // show path on map
                if ($('#map-rhumb-dest-canvas').is(':visible')) {
                    drawPath(p1.lat, p1.lon, p2.lat, p2.lon, maps.rhumbDest);
                }
            });
            $('#rhumb-dest .lat1').trigger('change'); // initial calculation

            // listener for map toggle
            $('#rhumb-dest .toggle-map a').click( function() {
                $('#rhumb-dest .toggle-map').toggle();
                $('#rhumb-dest .map').toggle();

                $('#rhumb-dest .lat1').trigger('change'); // to invoke drawPath()
            });

            // deg-min-sec / decimal degrees conversion
            $('#latDMS').change( function() { var lat = Dms.parseDMS($('#latDMS').val()); $('#latDM').val(Dms.toLat(lat,'dm',3)); $('#latD').val(Dms.toLat(lat,'d',5)); });
            $('#lonDMS').change( function() { var lon = Dms.parseDMS($('#lonDMS').val()); $('#lonDM').val(Dms.toLon(lon,'dm',3)); $('#lonD').val(Dms.toLon(lon,'d',5)); });
            $('#latDM').change( function() { var lat = Dms.parseDMS($('#latDM').val()); $('#latDMS').val(Dms.toLat(lat,'dms',1)); $('#latD').val(Dms.toLat(lat,'d',5)); });
            $('#lonDM').change( function() { var lon = Dms.parseDMS($('#lonDM').val()); $('#lonDMS').val(Dms.toLon(lon,'dms',1)); $('#lonD').val(Dms.toLon(lon,'d',5)); });
            $('#latD').change( function() { var lat = Dms.parseDMS($('#latD').val()); $('#latDMS').val(Dms.toLat(lat,'dms',1)); $('#latDM').val(Dms.toLat(lat,'dm',3)); });
            $('#lonD').change( function() { var lon = Dms.parseDMS($('#lonD').val()); $('#lonDMS').val(Dms.toLon(lon,'dms',1)); $('#lonDM').val(Dms.toLon(lon,'dm',3)); });

            // listener for display of bearings to user's preference
            $('input[name="deg-format"]').change(function() {
                // record preference in cookie
                Cookies.set('latlon-degree-format', degFmt = $(this).val());

                // trigger recalculations with new format
                $('#ortho-dist .lat1').trigger('change');
                $('#ortho-dest .lat1').trigger('change');
                $('#intersect  .lat1').trigger('change');
                $('#rhumb-dist .lat1').trigger('change');
                $('#rhumb-dest .lat1').trigger('change');
            });

            // ---- url query arguments for distance calculation...

            var from = Qs.parse(location.search.slice(1)).from;
            var to = Qs.parse(location.search.slice(1)).to;
            if (from && to) {
                from = from.split(',');
                to = to.split(',');
                $('#ortho-dist .lat1').val(from[0]);
                $('#ortho-dist .lon1').val(from[1]);
                $('#ortho-dist .lat2').val(to[0]);
                $('#ortho-dist .lon2').val(to[1]);
                //$('#ortho-dist .toggle-map a').trigger('click'); why no work?
                $('#ortho-dist .toggle-map').toggle(); // 'see on map' text
                $('#ortho-dist .map').toggle();        // the map itself
                $('#ortho-dist .lat1').trigger('change'); // to invoke drawPath()
            }


            // ---- ... & destination calculation

            var dist = Qs.parse(location.search.slice(1)).dist;
            var brng = Qs.parse(location.search.slice(1)).brng;
            if (from && dist && brng) {
                from = from.split(',');
                $('#ortho-dest .lat1').val(from[0]);
                $('#ortho-dest .lon1').val(from[1]);
                $('#ortho-dest .brng').val(brng);
                $('#ortho-dest .dist').val(dist);
                //$('#ortho-dist .toggle-map a').trigger('click'); why no work?
                $('#ortho-dest .toggle-map').toggle(); // 'see on map' text
                $('#ortho-dest .map').toggle();        // the map itself
                $('#ortho-dest .lat1').trigger('change'); // to invoke drawPath()
            }

            // show source code
            fetch('//cdn.rawgit.com/chrisveness/geodesy/v1.1.2/latlon-spherical.js')
                .then(function(res) { return res.ok ? res.text() : res.status+' '+res.statusText; })
                .then(function(txt) { doc.qrySel('#latlon-src').textContent = txt; prettyPrint(); })
                .catch(function(err) { doc.qrySel('#error').textContent = err.message; });
            fetch('//cdn.rawgit.com/chrisveness/geodesy/v1.1.2/dms.js')
                .then(function(res) { return res.ok ? res.text() : res.status+' '+res.statusText; })
                .then(function(txt) { doc.qrySel('#dms-src').textContent = txt; prettyPrint(); })
                .catch(function(err) { doc.qrySel('#error').textContent = err.message; });
        });

        function drawPath(lat1, lon1, lat2, lon2, m) {
            google.maps.event.trigger(m.map, 'resize');  // Gaaaaaah!

            // clear current overlays
            if (m.overlay.marker1) { m.overlay.marker1.setMap(null); m.overlay.marker1 = null; }
            if (m.overlay.marker2) { m.overlay.marker2.setMap(null); m.overlay.marker1 = null; }
            if (m.overlay.path)    { m.overlay.path.setMap(null);    m.overlay.path = null; }

            // if supplied lat/long are all valid numbers, draw the path
            if (!isNaN(lat1+lon1+lat2+lon2)) {
                var p1 = new google.maps.LatLng(lat1, lon1);
                var p2 = new google.maps.LatLng(lat2, lon2);
                var sw = new google.maps.LatLng(Math.min(lat1, lat2), Math.min(lon1, lon2));
                var ne = new google.maps.LatLng(Math.max(lat1, lat2), Math.max(lon1, lon2));
                var bnds = new google.maps.LatLngBounds(sw, ne);
                m.map.fitBounds(bnds);
                m.overlay.marker1 = new google.maps.Marker({ map:m.map, position:p1, title:'Point 1', icon:'http://maps.google.com/mapfiles/ms/icons/red-dot.png' });
                m.overlay.marker2 = new google.maps.Marker({ map:m.map, position:p2, title:'Point 2', icon:'http://maps.google.com/mapfiles/ms/icons/red.png' });
                m.overlay.path = new google.maps.Polyline({ map:m.map, path:[p1, p2], strokeColor:'#990000', geodesic:m.geodesic});
            }
        }
    </script>
</head>

<body>

<header> <a href="../"><img src="../images/mtl.gif" alt="MTL logo"></a>
  <h1>Movable Type Scripts</h1>
  <hr>
  <h2>Calculate distance, bearing and more between Latitude/Longitude points</h2>
</header>

<!--[if lte IE 9]><p class="alert align-left">This page no longer works on Internet Explorer 9 and earlier, which are <em><a href="https://www.microsoft.com/en-gb/WindowsForBusiness/End-of-IE-support">no longer supported</a></em></p><![endif]-->
<p class="error"></p>

<main>
    <p>This page presents a variety of calculations for lati&shy;tude/longi&shy;tude points, with the formulæ and
        code fragments for implementing them.</p>
    <p>All these formulæ are for calculations on the basis of a spherical earth  (ignoring ellipsoidal
        effects) – which is accurate enough<sup><a href="#ellipsoid" title="see notes">*</a></sup> for
        most purposes… [In fact, the earth is very slightly ellipsoidal; using a spherical model gives
        errors typically up to 0.3%<sup><a href="http://gis.stackexchange.com/questions/25494#25580">1</a></sup>
        – see notes for further details].</p>

    <form name="ortho-dist" id="ortho-dist">
        <fieldset><legend>Great-circle distance between two points</legend>
            <p>Enter the co-ordinates into the text boxes to try out the calculations. A variety of
                formats are accepted, principally:</p>
            <ul class="list">
                <li>deg-min-sec suffixed with N/S/E/W (e.g. 40°44′55″N, 73 59 11W), or</li>
                <li>signed decimal degrees without compass direction, where negative indicates
                    west/south (e.g. 40.7486, -73.9864):
                </li>
            </ul>
            <table class="inputs">
                <tr>
                    <td>Point 1:</td>
                    <td>
                        <input type="text" name="lat1" class="lat1" value="50 03 59N" placeholder="Lat 1 (°N/S)" title="Lat 1 (°N/S)" required> ,
                        <input type="text" name="lon1" class="lon1" value="005 42 53W" placeholder="Lon 1 (°E/W)" title="Lon 1 (°E/W)" required>
                    </td>
                </tr>
                <tr>
                    <td>Point 2:</td>
                    <td>
                        <input type="text" name="lat2" class="lat2" value="58 38 38N" placeholder="Lat 2 (°N/S)" title="Lat 2 (°N/S)" required> ,
                        <input type="text" name="lon2" class="lon2" value="003 04 12W" placeholder="Lon 2 (°E/W)" title="Lon 2 (°E/W)" required>
                    </td>
                </tr>
            </table>
            <table class="outputs">
                <tr>
                    <td>Distance:</td>
                    <td>
                        <output class="result-dist" title="Distance (in km)"></output> km
                        <span title="rounding to 4 significant figures reflects the approx. 0.3% accuracy of the spherical model"
                              class="small grey">(to 4 SF<sup>*</sup>)</span>
                    </td>
                </tr>
                <tr>
                    <td>Initial bearing:</td>
                    <td><output class="result-brng1" title="Initial bearing (azimuth) between points"></output></td>
                </tr>
                <tr>
                    <td>Final bearing:</td>
                    <td><output class="result-brng2" title="Final bearing (azimuth) between points"></output></td>
                </tr>
                <tr>
                    <td>Midpoint:</td>
                    <td><output class="result-midpt" title="Midpoint between points"></output></td>
                </tr>
            </table>
            <p class="toggle-map">And you can <a>see it on a map</a> (aren’t those Google guys wonderful!)</p>
            <p class="toggle-map hide"><a>... hide map</a></p>
            <div id="map-ortho-dist-canvas" class="map hide"></div>
        </fieldset>
    </form>


    <h3>Distance</h3>

    <p>This uses the ‘<b>haversine</b>’ formula to calculate the great-circle distance between two
        points – that is, the shortest distance over the earth’s surface – giving an ‘as-the-crow-flies’
        distance between the  points (ignoring any hills they fly over, of course!).</p>
    <table>
        <tr id='haversine'>
            <td class="label" rowspan="3">Haversine<br>formula:</td>
            <td class="formula">a = sin²(Δφ/2) + cos φ<sub>1</sub> ⋅ cos φ<sub>2</sub> ⋅ sin²(Δλ/2)</td>
        </tr>
        <tr>
            <td class="formula">c = 2 ⋅ atan2( &radic;<span class="radicand">a</span>, &radic;<span class="radicand">(1−a)</span> )</td>
        </tr>
        <tr>
            <td class="formula">d = R ⋅ c</td>
        </tr>
        <tr>
            <td class="label align-right">where</td>
            <td><i></i>φ<i> is latitude, </i>λ<i> is longitude, </i>R<i> is earth’s radius (mean radius = 6,371km);<br>
                note that angles need to be in radians to pass to trig functions!</i></td>
        </tr>
        <tr>
            <td class="label">JavaScript:</td>
            <td><pre class="code prettyprint>">
var R = 6371e3; // metres
var φ1 = lat1.toRadians();
var φ2 = lat2.toRadians();
var Δφ = (lat2-lat1).toRadians();
var Δλ = (lon2-lon1).toRadians();

var a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
        Math.cos(φ1) * Math.cos(φ2) *
        Math.sin(Δλ/2) * Math.sin(Δλ/2);
var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

var d = R * c;</pre>
            </td>
        </tr>
    </table>

    <p><i>Note in these scripts, I generally use lat/lon for lati&shy;tude/longi&shy;tude in degrees, and φ/λ for
        lati&shy;tude/longi&shy;tude in radians – having found that mixing degrees &amp; radians is often the
        easiest route to head-scratching bugs...</i></p>

    <aside><p><i>Historical aside</i>:
        The height of tech&shy;nology for navigator’s calculations used to be log tables. As there is no
        (real) log of a negative number, the ‘versine’ enabled them to keep trig func&shy;tions in
        positive numbers. Also, the sin²(θ/2) form of the haversine avoided addition (which en&shy;tailed
        an anti-log lookup, the addi&shy;tion, and a log lookup).
        Printed <a href="http://haversine.files.wordpress.com/2012/08/haversines.jpg">tables</a> for the
        haver&shy;sine/in&shy;verse-haver&shy;sine (and its log&shy;arithm, to aid
        multip&shy;lica&shy;tions) saved navi&shy;gators from squaring sines, com&shy;puting square roots,
        etc – arduous and error-prone activ&shy;ities.</p>
    </aside>

    <p>The <a href="http://en.wikipedia.org/wiki/Haversine_formula">haversine</a>
        formula<sup><a href="http://mathforum.org/library/drmath/view/51879.html">1</a></sup> ‘remains
        particularly well-conditioned for numerical computa&shy;tion even at small distances’ – unlike
        calcula&shy;tions based on the <span title="cos c = cos a cos b + sin a sin b cos C"><i>spherical law
        of cosines</i></span>. The ‘(re)versed sine’ is <span class="formula">1−cosθ</span>, and the
        ‘half-versed-sine’ is <span class="formula">(1−cosθ)/2</span> or <span class="formula">sin²(θ/2)</span> as used above.
        Once widely used by navigators, it was described by Roger Sinnott in
        <a href="https://www.shopatsky.com/product/sky-and-telescope-august-1984-digital-issue/sky-and-telescope-digital-issues-1980-1989"><i>Sky &amp; Telescope</i></a>
        magazine in 1984 (“Virtues of the Haversine”): Sinnott explained that the angular separa&shy;tion
        between Mizar and Alcor in Ursa Major – 0°11′49.69″ – could be accurately calculated on a
        <a href="http://en.wikipedia.org/wiki/TRS-80#modeliii">TRS-80</a> using the haversine.</p>
    <p>For the curious, <i>c</i> is the angular distance in radians, and <i>a</i> is the square of half
        the chord length between the points.</p>
    <p>If <code>atan2</code> is not available, <i>c</i> could be calculated
        from <span class="formula">2 ⋅ asin( min(1, &radic;<span class="radicand">a</span>) )</span>
        (including protec&shy;tion against rounding errors).</p>
    <p>Using Chrome on a middling Core i5 PC, a distance calcula&shy;tion takes around
        <a href="performance/latlong-spherical.html">2 – 5 micro&shy;seconds</a> (hence around 200,000 – 500,000 per second).
        Little to no benefit is obtained by factoring out common terms; probably the JIT compiler
        optimises them out.</p>

    <h4 id="cosine-law">Spherical Law of Cosines</h4>

    <p>In fact, JavaScript (and most modern computers & languages) use ‘IEEE 754’ 64-bit floating-point
        numbers, which provide 15 significant figures of precision. By my estimate, with this precision,
        the simple <a href="http://mathworld.wolfram.com/SphericalTrigonometry.html">spherical law of
        cosines</a> formula (cos <i>c</i> = cos <i>a</i> cos <i>b</i> + sin <i>a</i> sin <i>b</i> cos <i>C</i>)
        gives well-condi&shy;tioned results down to distances as small as a few metres on the earth’s surface.
        <span class="note">(<i>Note that the geodetic form of the law of cosines is rearranged from the
        canonical one so that the latitude can be used directly, rather than the
        <a href="http://mathworld.wolfram.com/Colatitude.html">colatitude</a></i>).</span></p>
    <p>This makes the simpler law of cosines a reasonable 1-line alternative to the haversine formula for
        many geodesy purposes (if not for astronomy). The choice may be driven by programming language, processor,
        coding context, available trig func&shy;tions (in different languages), etc – and, for very small distances an
        equirectangular approxima&shy;tion may be more suitable.</p>

    <table>
        <tr>
            <td class="label">Law of cosines:</td>
            <td class="formula">d = acos( sin φ<sub>1</sub> ⋅ sin φ<sub>2</sub> + cos φ<sub>1</sub> ⋅ cos φ<sub>2</sub> ⋅ cos Δλ ) ⋅ R</td>
        </tr>
        <tr>
            <td class="label">JavaScript:</td>
            <td><pre class="code prettyprint>">
var φ1 = lat1.toRadians(), φ2 = lat2.toRadians(), Δλ = (lon2-lon1).toRadians(), R = 6371e3; // gives d in metres
var d = Math.acos( Math.sin(φ1)*Math.sin(φ2) + Math.cos(φ1)*Math.cos(φ2) * Math.cos(Δλ) ) * R;</pre>
            </td>
        </tr>
        <tr>
            <td class="label">Excel:</td>
            <td class="code">=ACOS( SIN(lat1)*SIN(lat2) + COS(lat1)*COS(lat2)*COS(lon2-lon1) ) * 6371000</td>
        </tr>
        <tr>
            <td class="label">(or with lat/lon in degrees):</td>
            <td class="code">=ACOS( SIN(lat1*PI()/180)*SIN(lat2*PI()/180) + COS(lat1*PI()/180)*COS(lat2*PI()/180)*COS(lon2*PI()/180-lon1*PI()/180) ) * 6371000</td>
        </tr>
    </table>
    <p>While simpler, the law of cosines is slightly slower than the haversine, in my tests.</p>

    <h4 id="equirectangular">Equirectangular approximation</h4>

    <p>If performance is an issue and accuracy less important, for small distances
        <a href="http://en.wikipedia.org/wiki/Pythagorean_theorem">Pythagoras’
        theorem</a> can be used on an <a href="http://en.wikipedia.org/wiki/Equirectangular_projection">equi&shy;rectangular
        projec&shy;tion</a>:<sup title="merci à Laurent Grégoire">*</sup></p>
    <table>
        <tr>
            <td class="label">Formula</td>
            <td class="formula">x = Δλ ⋅ cos φ<sub>m</sub></td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">y = Δφ</td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">d = R ⋅ &radic;<span class="radicand">x² + y²</td>
        </tr>
        <tr>
        <td class="label">JavaScript:</td>
        <td><pre class="code prettyprint>">
var x = (λ2-λ1) * Math.cos((φ1+φ2)/2);
var y = (φ2-φ1);
var d = Math.sqrt(x*x + y*y) * R;</pre></td>
        </tr>
    </table>

    <p>This uses just one trig and one sqrt function – as against half-a-dozen trig func&shy;tions for cos
        law, and 7 trigs + 2 sqrts for haversine. Accuracy is somewhat complex: along meridians there
        are no errors, otherwise they depend on distance, bearing, and latitude, but are small enough
        for many purposes<sup title="anyone care to quantify them?">*</sup> (and often trivial compared
        with the spherical approxima&shy;tion itself).</p>

    <p>Alternatively, the <i>polar coordinate flat-earth formula</i> can be used:
        using the co-latitudes θ<sub>1</sub> = π/2−φ<sub>1</sub> and θ<sub>2</sub> = π/2−φ<sub>2</sub>,
        then <span class="formula nowrap">d = R ⋅ &radic;<span class="radicand">θ<sub>1</sub>² + θ<sub>2</sub>² − 2 ⋅ θ<sub>1</sub> ⋅ θ<sub>2</sub> ⋅ cos Δλ</span></span>.
        I’ve not compared accuracy.</p>

    <figure class="float-right"><img src="baghdad-to-osaka.jpg" alt="Baghdad to Osaka">
        <figcaption>Baghdad to Osaka – <br>
        not a constant bearing!</figcaption>
    </figure>

    <h3 id="bearing">Bearing</h3>

    <p>In general, your current heading will vary as you  follow a great circle path (orthodrome); the
        final heading will differ from the initial heading by varying degrees according to distance and
        latitude (if you were to go from say 35°N,45°E (≈&nbsp;Baghdad) to 35°N,135°E (≈&nbsp;Osaka), you
        would start on a heading of 60° and end up on a heading of 120°!).</p>
    <p>This formula is for the initial bearing (sometimes referred to as forward azimuth) which if
        followed in a straight line along a great-circle arc will take you from the start point to the
        end point:<sup><a href="http://mathforum.org/library/drmath/view/55417.html">1</a></sup></p>
    <table>
        <tr>
            <td class="label">Formula:</td>
            <td class="formula">θ = atan2( sin Δλ ⋅ cos φ<sub>2</sub> , cos φ<sub>1</sub> ⋅ sin φ<sub>2</sub>  − sin φ<sub>1</sub> ⋅ cos φ<sub>2</sub> ⋅ cos Δλ )</td>
        </tr>
        <tr>
            <td class="label align-right">where</td>
            <td><i></i>φ<sub>1</sub><i>,</i>λ<sub>1</sub><i> is the start point,
                </i>φ<sub>2</sub><i>,</i>λ<sub>2</sub><i> the end point (</i>Δλ<i> is the difference in longitude)</i></td>
        </tr>
        <tr>
            <td class="label">JavaScript:<div class="small grey">(all angles <br>in radians)</div></td>
            <td><pre class="code prettyprint>">
var y = Math.sin(λ2-λ1) * Math.cos(φ2);
var x = Math.cos(φ1)*Math.sin(φ2) -
        Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
var brng = Math.atan2(y, x).toDegrees();</pre></td>
        </tr>
        <tr>
            <td class="label">Excel:<div class="small grey">(all angles <br>in radians)</div></td>
            <td class="code nowrap">=ATAN2(COS(lat1)*SIN(lat2)-SIN(lat1)*COS(lat2)*COS(lon2-lon1), <br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SIN(lon2-lon1)*COS(lat2))
                <br><span class="note">*note that Excel reverses the arguments to ATAN2 – see notes below</span>
            </td>
        </tr>
    </table>
    <p class="note">Since atan2 returns values in the range -π ... +π (that is, -180° ... +180°), to
        normalise the result to a compass bearing (in the range 0° ... 360°, with −ve values transformed
        into the range 180° ... 360°), convert to degrees and then use (θ+360)&nbsp;%&nbsp;360, where %
        is (floating point) modulo.</p>
    <p class="note">For final bearing, simply take the <i>initial</i> bearing from the <i>end</i> point
        to the <i>start</i> point and reverse it (using θ = (θ+180) % 360).</p>

    <h3 id="midpoint">Midpoint</h3>

    <p>This is the half-way point along a great circle path between the two
        points.<sup><a href="http://mathforum.org/library/drmath/view/51822.html" title="Mathforum derivation">1</a></sup></p>
    <table>
        <tr>
            <td class="label">Formula:</td>
            <td class="formula">B<sub>x</sub> = cos φ<sub>2</sub> ⋅ cos Δλ</td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">B<sub>y</sub> = cos φ<sub>2</sub> ⋅ sin Δλ</td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">φ<sub>m</sub> = atan2( sin φ<sub>1</sub> + sin φ<sub>2</sub>,
                &radic;<span class="radicand">(cos φ<sub>1</sub> + B<sub>x</sub>)² + B<sub>y</sub>²</span> )</td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">λ<sub>m</sub> = λ<sub>1</sub> + atan2(B<sub>y</sub>, cos(φ<sub>1</sub>)+B<sub>x</sub>)</td>
        </tr>
        <tr>
            <td class="label">JavaScript:<div class="small grey">(all angles <br>in radians)</div></td>
            <td><pre class="code prettyprint>">
var Bx = Math.cos(φ2) * Math.cos(λ2-λ1);
var By = Math.cos(φ2) * Math.sin(λ2-λ1);
var φ3 = Math.atan2(Math.sin(φ1) + Math.sin(φ2),
                    Math.sqrt( (Math.cos(φ1)+Bx)*(Math.cos(φ1)+Bx) + By*By ) );
var λ3 = λ1 + Math.atan2(By, Math.cos(φ1) + Bx);</pre></td>
        </tr>
        <tr>
            <td></td>
            <td class="note">The longitude can be normalised to −180…+180 using <code>(lon+540)%360-180</code></td>
        </tr>
    </table>

    <p class="note">Just as the initial bearing may vary from the final bearing, the midpoint may
        not be located half-way between latitudes/longitudes; the midpoint between 35°N,45°E
        and 35°N,135°E is around 45°N,90°E.</p>

    <h4 id="intermediate-point">Intermediate point</h4>

    <p>An intermediate point at any fraction along the great circle path between two points can also be
        calculated.<sup><a href="http://www.edwilliams.org/avform.htm#Intermediate" title="from Ed William’s aviation formulary">1</a></sup></p>

    <table>
        <tr>
            <td class="label">Formula:</td>
            <td class="formula">a = sin((1−f)⋅δ) / sin δ</td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">b = sin(f⋅δ) / sin δ</td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">x = a ⋅ cos φ<sub>1</sub> ⋅ cos λ<sub>1</sub> + b ⋅ cos φ<sub>2</sub> ⋅ cos λ<sub>2</sub></td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">y = a ⋅ cos φ<sub>1</sub> ⋅ sin λ<sub>1</sub> + b ⋅ cos φ<sub>2</sub> ⋅ sin λ<sub>2</sub></td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">z = a ⋅ sin φ<sub>1</sub> + b ⋅ sin φ<sub>2</sub></td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">φ<sub>i</sub> = atan2(z, &radic;<span class="radicand">x² + y²)</span></td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">λ<sub>i</sub> = atan2(y, x)</td>
        </tr>
        <tr>
            <td class="label align-right">where</td>
            <td><i></i>f<i> is fraction along great circle route (f=0 is point 1, f=1 is point 2), </i>δ<i> is the angular
                distance </i>d/R<i> between the two points.</i></td>
        </tr>
    </table>
    <p>&nbsp;</p>

    <hr>

    <h3 id="destPoint"><b>Destination point given distance and bearing from start point</b></h3>

    <p>Given a start point, initial bearing, and distance, this will calculate the destina&shy;tion point and
        final bearing travelling along a (shortest distance) great circle arc.</p>

    <form name="ortho-dest" id="ortho-dest">
        <fieldset><legend>Destination point along great-circle given distance and bearing from start point</legend>
            <table class="inputs">
                <tr>
                    <td>Start point:</td>
                    <td>
                    <input name="lat1" class="lat1" type="text" value="53°19′14″N">,
                    <input name="lon1" class="lon1" type="text" value="001°43′47″W"></td>
                </tr>
                <tr>
                    <td>Bearing:</td>
                    <td><input type="text" name="brng" class="brng" value="096°01′18″"></td>
                </tr>
                <tr>
                    <td>Distance:</td>
                    <td><input name="dist" class="dist" type="number" step="any" value="124.8"> km</td>
                </tr>
            </table>
            <table class="outputs">
                <tr>
                    <td>Destination point:</td>
                    <td><output class="result-point" title="Destination point"></output></td>
                </tr>
                <tr>
                    <td>Final bearing:</td>
                    <td><output class="result-brng" title="Final bearing (azimuth) arriving at point 2"></output></td>
                </tr>
                <tr>
                    <td>
                        <p class="toggle-map"><a>view map</a></p>
                        <p class="toggle-map hide"><a>hide map</a></p>
                    </td>
                    <td></td>
                </tr>
            </table>
            <div id="map-ortho-dest-canvas" class="map hide"></div>
        </fieldset>
    </form>

    <table>
        <tr>
            <td class="label">Formula: </td>
            <td class="formula">φ<sub>2</sub> = asin( sin φ<sub>1</sub> ⋅ cos δ + cos φ<sub>1</sub> ⋅ sin δ ⋅ cos θ )</td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">λ<sub>2</sub> = λ<sub>1</sub> + atan2( sin θ ⋅ sin δ ⋅ cos φ<sub>1</sub>, cos δ − sin φ<sub>1</sub> ⋅ sin φ<sub>2</sub> )</td>
        </tr>
        <tr>
            <td class="label align-right">where</td>
            <td><i></i>φ<i> is latitude, </i>λ<i> is longitude, </i>θ<i> is the bearing (clockwise from north),
                δ is the angular distance </i>d/R<i>; </i>d<i> being the distance travelled, </i>R<i> the earth’s radius</i></td>
        </tr>
        <tr>
            <td class="label">JavaScript:<div class="small grey">(all angles <br>in radians)</div></td>
            <td><pre class="code prettyprint>">
var φ2 = Math.asin( Math.sin(φ1)*Math.cos(d/R) +
                    Math.cos(φ1)*Math.sin(d/R)*Math.cos(brng) );
var λ2 = λ1 + Math.atan2(Math.sin(brng)*Math.sin(d/R)*Math.cos(φ1),
                         Math.cos(d/R)-Math.sin(φ1)*Math.sin(φ2));</pre></td>
        </tr>
        <tr>
            <td></td>
            <td class="note">The longitude can be normalised to −180…+180 using <code>(lon+540)%360-180</code></td>
        </tr>
        <tr>
            <td class="label">Excel:<div class="small grey">(all angles <br>in radians)</div></td>
            <td class="code">lat2: =ASIN(SIN(lat1)*COS(d/R) + COS(lat1)*SIN(d/R)*COS(brng))<br>
                lon2: =lon1 + ATAN2(COS(d/R)-SIN(lat1)*SIN(lat2), SIN(brng)*SIN(d/R)*COS(lat1))
                <br><span class="note">* Remember that Excel reverses the arguments to ATAN2 – see notes below</span></td>
        </tr>
    </table>

    <p class="note">For final bearing, simply take the <i>initial</i> bearing from the <i>end</i> point to the <i>start</i>
        point and reverse it with <code>(brng+180)%360</code>.</p>
    <p>&nbsp;</p>

    <hr>

    <h3 id="intersection">Intersection of two paths given start points and bearings</h3>

    <p>This is a rather more complex calculation than most others on this page, but I've been asked for it a number of times.
        This comes from Ed William’s <a href="http://www.edwilliams.org/avform.htm#Intersection">aviation formulary</a>.
        See below for the JavaScript.</p>

    <form name="intersect" id="intersect">
        <fieldset><legend>Intersection of two great-circle paths</legend>
            <table class="inputs">
                <tr>
                    <td>Point 1:</td>
                    <td>
                    <input name="lat1" class="lat1" type="text" value="51.8853 N" title="Latitude 1">,
                    <input name="lon1" class="lon1" type="text" value="0.2545 E" title="Longitude 1">
                    Brng 1:
                    <input name="brng1" class="brng1" type="text" value="108.55°" title="Bearing 1">
                    </td>
                </tr>
                <tr>
                    <td>Point 2:</td>
                    <td>
                    <input name="lat2" class="lat2" type="text" value="49.0034 N" title="Latitude 2">,
                    <input name="lon2" class="lon2" type="text" value="2.5735 E" title="Longitude 2">
                    Brng 2:
                    <input name="brng1" class="brng2" type="text" value="32.44°" title="Bearing 2">
                    </td>
                </tr>
            </table>
            <table class="outputs">
                <tr>
                    <td>Intersection point:</td>
                    <td><output class="result-point" title="Intersection point"></output></td>
                </tr>
                <tr>
                    <td colspan="2"><p>&nbsp;</p></td>
                </tr>
            </table>
        </fieldset>
    </form>

    <table class="clear-floats">
        <tr>
            <td class="label">Formula:</td>
            <td class="formula">δ<sub>12</sub> = 2⋅asin( &radic;<span class="radicand">(sin²(Δφ/2) + cos φ<sub>1</sub> ⋅ cos φ<sub>2</sub> ⋅ sin²(Δλ/2))</span> )</td>
            <td class="small grey align-right">angular dist. p1–p2</td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">θ<sub>a</sub> = acos( ( sin φ<sub>2</sub>  − sin φ<sub>1</sub> ⋅ cos δ<sub>12</sub> ) / ( sin δ<sub>12</sub> ⋅ cos φ<sub>1</sub> ) )<br>
                                θ<sub>b</sub> = acos( ( sin φ<sub>1</sub>  − sin φ<sub>2</sub> ⋅ cos δ<sub>12</sub> ) / ( sin δ<sub>12</sub> ⋅ cos φ<sub>2</sub> ) )</td>
            <td class="small grey align-right">initial / final bearings<br>between points 1 &amp; 2</td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">if sin(λ<sub>2</sub>−λ<sub>1</sub>) &gt; 0<br>
                &nbsp;&nbsp;&nbsp;&nbsp;θ<sub>12</sub> = θ<sub>a</sub><br>
                &nbsp;&nbsp;&nbsp;&nbsp;θ<sub>21</sub> = 2π − θ<sub>b</sub><br>
                else<br>
                &nbsp;&nbsp;&nbsp;&nbsp;θ<sub>12</sub> = 2π − θ<sub>a</sub><br>
                &nbsp;&nbsp;&nbsp;&nbsp;θ<sub>21</sub> = θ<sub>b</sub></td>
            <td class="small grey align-right"></td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">α<sub>1</sub> = θ<sub>13</sub> − θ<sub>12</sub><br>
                                α<sub>2</sub> = θ<sub>21</sub> − θ<sub>23</sub></td>
            <td class="small grey align-right">angle p2–p1–p3<br>angle p1–p2–p3</td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">α<sub>3</sub> = acos( −cos α<sub>1</sub> ⋅ cos α<sub>2</sub> + sin α<sub>1</sub> ⋅ sin α<sub>2</sub> ⋅ cos δ<sub>12</sub> )</td>
            <td class="small grey align-right">angle p1–p2–p3</td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">δ<sub>13</sub> = atan2( sin δ<sub>12</sub> ⋅ sin α<sub>1</sub> ⋅ sin α<sub>2</sub> , cos α<sub>2</sub> + cos α<sub>1</sub> ⋅ cos α<sub>3</sub> )</td>
            <td class="small grey align-right">angular dist. p1–p3</td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">φ<sub>3</sub> = asin( sin φ<sub>1</sub> ⋅ cos δ<sub>13</sub> + cos φ<sub>1</sub> ⋅ sin δ<sub>13</sub> ⋅ cos θ<sub>13</sub> )</td>
            <td class="small grey align-right">p3 lat</td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">Δλ<sub>13</sub> = atan2( sin θ<sub>13</sub> ⋅ sin δ<sub>13</sub> ⋅ cos φ<sub>1</sub> , cos δ<sub>13</sub> − sin φ<sub>1</sub> ⋅ sin φ<sub>3</sub> )</td>
            <td class="small grey align-right">long p1–p3</td>
        </tr>
        <tr>
            <td></td>
            <td class="formula">λ<sub>3</sub> = λ<sub>1</sub> + Δλ<sub>13</sub></td>
            <td class="small grey align-right">p3 long</td>
        </tr>
      <tr>
        <td class="label align-right"><i>where</i></td>
        <td><p><i>φ<sub>1</sub>, λ<sub>1</sub>, θ<sub>13</sub> : 1st start point &amp; (initial) bearing from 1st point towards intersection point<br>
          φ<sub>2</sub>, λ<sub>2</sub>, θ<sub>23</sub> : 2nd start point &amp; (initial) bearing from 2nd point towards intersection point<br>
          φ<sub>3</sub>, λ<sub>3</sub> : intersection point</i></p>
            <p><i>% = (floating point) modulo<!--, | | = abs--></i></p></td>
      </tr>
      <tr>
        <td class="label align-right">note –</td>
        <td>if sin α<sub>1</sub> = 0 and sin α<sub>2</sub> = 0: infinite solutions<br>
          if sin α<sub>1</sub> ⋅ sin α<sub>2</sub>  &lt; 0: ambiguous solution<br>
          this formulation is not always well-conditioned for meridional or equatorial lines</td>
      </tr>
    </table>
<p>This is a lot simpler using vectors rather than spherical trigonometry:
    see <a href="latlong-vectors.html#intersection">latlong-vectors.html</a>.</p>
<hr>

<h3 id="cross-track">Cross-track distance</h3>

<p>Here’s a new one:  I’ve sometimes been asked about distance of a point from a great-circle path
    (sometimes called cross track error).</p>

<table>
    <tr>
        <td class="label">Formula: </td>
        <td class="formula">d<sub>xt</sub> = asin( sin(δ<sub>13</sub>) ⋅ sin(θ<sub>13</sub>−θ<sub>12</sub>) ) ⋅ R</td>
    </tr>
    <tr>
        <td class="label align-right"><i>where</i></td>
        <td><i>
            δ<sub>13</sub> is (angular) distance from start point to third point<br>
            θ<sub>13</sub> is (initial) bearing from start point to third point<br>
            θ<sub>12</sub> is (initial) bearing from start point to end point<br>
            R is the earth’s radius<br>
            </i>
        </td>
    </tr>
    <tr>
        <td class="label">JavaScript:</td>
        <td><pre class="code prettyprint>">
var δ13 = d13 / R;
var dXt = Math.asin(Math.sin(δ13)*Math.sin(θ13-θ12)) * R;</pre></td>
    </tr>
</table>

<p>Here, the great-circle path is identified by a start point and an end point – depending on what initial data you’re working from,
    you can use the formulæ above to obtain the relevant distance and bearings.
    The sign of d<sub>xt</sub> tells you which side of the path the third point is on.</p>
<p>The along-track distance, from the start point to the closest point on the path to the third point, is</p>
<table>
    <tr>
        <td class="label">Formula: </td>
        <td class="formula">d<sub>at</sub> = acos( cos(δ<sub>13</sub>) / cos(δ<sub>xt</sub>) ) ⋅ R</td>
    </tr>
    <tr>
        <td class="label align-right"><i>where</i></td>
        <td><i>
            δ<sub>13</sub> is (angular) distance from start point to third point<br>
            δ<sub>xt</sub> is (angular) cross-track distance<br>
            R is the earth’s radius<br>
            </i>
        </td>
    </tr>
    <tr>
        <td class="label">JavaScript:</td>
        <td><pre class="code prettyprint>">
var δ13 = d13 / R;
var dAt = Math.acos(Math.cos(δ13)/Math.cos(dXt/R)) * R;</pre></td>
    </tr>
</table>

<h3 id="clairaut">Closest point to the poles</h3>

<p>And: ‘Clairaut’s formula’ will give you the maximum latitude of a great circle path,
  given a bearing θ and latitude φ on the great circle:
<table>
    <tr>
        <td class="label">Formula: </td>
        <td class="formula">φ<sub>max</sub> = acos( | sin θ ⋅ cos φ | )</td>
    </tr>
    <tr>
        <td class="label">JavaScript:</td>
        <td><pre class="code prettyprint>">var φMax = Math.acos(Math.abs(Math.sin(θ)*Math.cos(φ)));</pre></td>
    </tr>
</table>
<p>&nbsp;</p>

<hr>

<h3 id="rhumblines">Rhumb lines</h3>

<p>A ‘rhumb line’ (or loxodrome) is a path of constant bearing, which crosses all meridians at the
    same angle.</p>
<p>Sailors used to (and sometimes still) navigate along rhumb lines since it is easier to follow
    a constant compass  bearing than to be continually adjusting the bearing, as is needed to follow
    a great circle. Rhumb lines are straight lines on a Mercator Projec&shy;tion map (also helpful for
    naviga&shy;tion).</p>
<p>Rhumb lines are generally longer than great-circle (orthodrome) routes. For instance, London to New
    York is  4% longer along a rhumb line than along a great circle – important for avia&shy;tion fuel,
    but not particularly to sailing vessels. New York to Beijing – close to the most extreme example
    possible (though not sailable!) – is 30% longer along a rhumb line.</p>

<form name="rhumb-dist" id="rhumb-dist">
    <fieldset><legend>Rhumb-line distance between two points</legend>
        <table class="inputs">
            <tr>
                <td>Point 1:</td>
                <td>
                <input name="lat1" class="lat1" type="text" value="50 21 59N" title="Latitude 1">,
                <input name="lon1" class="lon1" type="text" value="004 08 02W" title="Longitude 1">
                </td>
            </tr>
            <tr>
                <td>Point 2:</td>
                <td>
                <input name="lat2" class="lat2" type="text" value="42 21 04N" title="Latitude 2">,
                <input name="lon2" class="lon2" type="text" value="071 02 27W" title="Longitude 2">
                </td>
            </tr>
        </table>
        <table class="outputs">
            <tr>
                <td>Distance:</td>
                <td><output class="result-dist" title="Distance (in km)"></output> km</td>
            </tr>
            <tr>
                <td>Bearing:</td>
                <td><output class="result-brng" title="Bearing (azimuth) between points"></output></td>
            </tr>
            <tr>
                <td>Midpoint:</td>
                <td><output class="result-midpt" title="Midpoint between points"></output></td>
            </tr>
            <tr>
                <td>
                    <p class="toggle-map"><a>view map</a></p>
                    <p class="toggle-map hide"><a>hide map</a></p>
                </td>
                <td></td>
            </tr>
        </table>
        <div id="map-rhumb-dist-canvas" class="map hide"></div>
    </fieldset>
</form>

<form name="rhumb-dest" id="rhumb-dest" class="demo">
    <fieldset><legend>Destination point along rhumb line given distance and bearing from start point</legend>
        <table class="inputs">
            <tr>
                <td>Start point:</td>
                <td>
                    <input name="lat1" class="lat1" type="text" value="51 07 32N">,
                    <input name="lon1" class="lon1" type="text" value="001 20 17E">
                </td>
            </tr>
            <tr>
                <td>Bearing:</td>
                <td><input name="brng" class="brng" type="text" value="116°38′10"></td>
            </tr>
            <tr>
                <td>Distance:</td>
                <td><input name="dist" class="dist" type="number" step="any" value="40.23">
                km</td>
            </tr>
        </table>
        <table class="outputs">
            <tr>
                <td>Destination point:</td>
                <td><output class="result-point" title="Destination points"></output></td>
            </tr>
            <tr>
                <td>
                    <p class="toggle-map"><a>view map</a></p>
                    <p class="toggle-map hide"><a>hide map</a></p>
                </td>
                <td></td>
            </tr>
        </table>
        <div id="map-rhumb-dest-canvas" class="map hide"></div>
        <p>&nbsp;</p>
    </fieldset>
</form>

<p>Key to calculations of rhumb lines is the <i>inverse Gudermannian
    func&shy;tion</i><a href="http://mathworld.wolfram.com/InverseGudermannian.html">¹</a>, which gives
    the height on a Mercator projec&shy;tion map of a given latitude:
    <span class="formula">ln(tanφ + secφ)</span> or <span class="formula">ln( tan(π/4+φ/2) )</span>.
    This of course tends to infinity at the poles (in keeping with the Mercator projec&shy;tion).
    <span class="grey">For obsessives, there is even an ellipsoidal version, the ‘isometric latitude’:
    <span class="formula">ψ = ln( tan(π/4+φ/2) / [ (1−e⋅sinφ) / (1+e⋅sinφ)&nbsp;]<sup>e/2</sup>)</span>,
    or its better-conditioned equivalent <span class="formula">ψ = atanh(sinφ) − e⋅atanh(e⋅sinφ)</span>.</span>
</p>
<p>The formulæ to derive Mercator projection easting and northing coordinates from spherical latitude
    and longitude are then<a href="http://www.epsg.org/guides/docs/g7-2.pdf">¹</a></p>
<table class="width-full">
    <tr>
        <td></td>
        <td class="formula">E = R ⋅ λ</td>
    </tr>
    <tr>
        <td></td>
        <td class="formula">N = R ⋅ ln( tan(π/4 + φ/2) )</td>
    </tr>
</table>
<p>The following formulæ are from Ed Williams’ aviation formulary.<a href="http://www.edwilliams.org/avform.htm#Rhumb">¹</a></p>

<h4 id="rhumb-distance">Distance</h4>

<p>Since a rhumb line is a straight line on a Mercator projec&shy;tion, the distance between two points
    along a rhumb line is the length of that line (by Pythagoras); but the distor&shy;tion of the
    projec&shy;tion needs to be compensated for.</p>
<p>On a constant latitude course (travelling east-west), this compensa&shy;tion is simply
    <span class="formula">cosφ</span>; in the general case, it is <span class="formula">Δφ/Δψ</span>
    where <span class="formula">Δψ = ln( tan(π/4 + φ<sub>2</sub>/2) / tan(π/4 + φ<sub>1</sub>/2) )</span>
    (the ‘projected’ latitude difference)</p>
<table class="width-full">
    <tr>
        <td class="label">Formula: </td>
        <td class="formula">Δψ = ln( tan(π/4 + φ<sub>2</sub>/2) / tan(π/4 + φ<sub>1</sub>/2) )</td>
        <td class="small grey align-right">(‘projected’ latitude difference)</td>
    </tr>
    <tr>
        <td></td>
        <td class="formula">q = Δφ/Δψ (or cosφ for E-W line)</td>
        <td></td>
    </tr>
    <tr>
        <td></td>
        <td class="formula">d = &radic;<span class="radicand">(Δφ² + q²⋅Δλ²)</span> ⋅ R</td>
        <td class="small grey align-right">(Pythagoras)</td>
    </tr>
    <tr>
        <td class="label align-right">where</td>
        <td colspan="2">φ <i>is latitud</i>e, λ <i>is longitude</i>,
            Δλ<i> is taking shortest route (&lt;180°),
            </i>R<i> is the earth’s radius</i>, ln<i> is natural log</i></td>
    </tr>
    <tr>
        <td class="label">JavaScript:<div class="small grey">(all angles <br>in radians)</div></td>
        <td colspan="2"><pre class="code prettyprint>">
var Δψ = Math.log(Math.tan(Math.PI/4+φ2/2)/Math.tan(Math.PI/4+φ1/2));
var q = Math.abs(Δψ) &gt; 10e-12 ? Δφ/Δψ : Math.cos(φ1); // E-W course becomes ill-conditioned with 0/0

// if dLon over 180° take shorter rhumb line across the anti-meridian:
if (Math.abs(Δλ) &gt; Math.PI) Δλ = Δλ>0 ? -(2*Math.PI-Δλ) : (2*Math.PI+Δλ);

var dist = Math.sqrt(Δφ*Δφ + q*q*Δλ*Δλ) * R;</pre>
        </td>
    </tr>
</table>

<h4 id="rhumb-bearing">Bearing</h4>

<p>A rhumb line is a straight line on a Mercator projection, with an angle on the projec&shy;tion equal
    to the compass bearing.</p>

<table class="width-full">
    <tr>
        <td class="label">Formula: </td>
        <td class="formula">Δψ = ln( tan(π/4 + φ<sub>2</sub>/2) / tan(π/4 + φ<sub>1</sub>/2) )</td>
        <td class="small grey align-right">(‘projected’ latitude difference)</td>
    </tr>
    <tr>
        <td></td>
        <td class="formula">θ = atan2(Δλ, Δψ)</td>
        <td></td>
    </tr>
    <tr>
        <td class="label align-right">where</td>
        <td colspan="2">φ <i>is latitud</i>e, λ <i>is longitude</i>,
            Δλ<i> is taking shortest route (&lt;180°),
            </i>R<i> is the earth’s radius</i>, ln<i> is natural log</i></td>
    </tr>
    <tr>
        <td class="label">JavaScript:<div class="small grey">(all angles <br>in radians)</div></td>
        <td colspan="2"><pre class="code prettyprint>">
var Δψ = Math.log(Math.tan(Math.PI/4+φ2/2)/Math.tan(Math.PI/4+φ1/2));

// if dLon over 180° take shorter rhumb line across the anti-meridian:
if (Math.abs(Δλ) &gt; Math.PI) Δλ = Δλ>0 ? -(2*Math.PI-Δλ) : (2*Math.PI+Δλ);

var brng = Math.atan2(Δλ, Δψ).toDegrees();</pre></td>
    </tr>
</table>

<h4 id="rhumb-destination">Destination</h4>

<p>Given a start point and a distance <i>d</i> along constant bearing <i>θ</i>, this will calculate
    the destina&shy;tion point. If you maintain a constant bearing along a rhumb line, you will gradually
    spiral in towards one of the poles. </p>
<table class="width-full">
    <tr>
        <td class="label">Formula: </td>
        <td class="formula">δ = d/R</td>
        <td class="small grey align-right">(angular distance)</td>
    </tr>
    <tr>
        <td></td>
        <td class="formula">φ<sub>2</sub> = φ<sub>1</sub> + δ ⋅ cos θ</td>
        <td></td>
    </tr>
    <tr>
        <td></td>
        <td class="formula">Δψ = ln( tan(π/4 + φ<sub>2</sub>/2) / tan(π/4 + φ<sub>1</sub>/2) )</td>
        <td class="small grey align-right">(‘projected’ latitude difference)</td>
    </tr>
    <tr>
        <td></td>
        <td class="formula">q = Δφ/Δψ (or cos φ for E-W line)</td>
        <td></td>
    </tr>
    <tr>
        <td></td>
        <td class="formula">Δλ = δ ⋅ sin θ / q</td>
        <td></td>
    </tr>
    <tr>
        <td></td>
        <td class="formula">λ<sub>2</sub> = λ<sub>1</sub> + Δλ</td>
        <td></td>
    </tr>
    <tr>
        <td class="label align-right">where</td>
        <td colspan="2">φ <i>is latitude</i>, λ <i>is longitude</i>, Δλ <i>is taking shortest route
            (&lt;180°), </i>ln<i> is natural log, </i>R<i> is the earth’s radius</i></td>
    </tr>
    <tr>
        <td class="label">JavaScript:<div class="small grey">(all angles <br>in radians)</div></td>
        <td colspan="2"><pre class="code prettyprint>">
var δ = d/R;
var Δφ = δ * Math.cos(θ);
var φ2 = φ1 + Δφ;

var Δψ = Math.log(Math.tan(φ2/2+Math.PI/4)/Math.tan(φ1/2+Math.PI/4));
var q = Math.abs(Δψ) > 10e-12 ? Δφ / Δψ : Math.cos(φ1); // E-W course becomes ill-conditioned with 0/0

var Δλ = δ*Math.sin(θ)/q;
var λ2 = λ1 + Δλ;

// check for some daft bugger going past the pole, normalise latitude if so
if (Math.abs(φ2) &gt; Math.PI/2) φ2 = φ2>0 ? Math.PI-φ2 : -Math.PI-φ2;</pre></td>
    </tr>
    <tr>
        <td></td>
        <td colspan="2" class="note">The longitude can be normalised to −180…+180 using <code>(lon+540)%360-180</code></td>
    </tr>
</table>

<h4>Mid-point</h4>

<p>This formula for calculating the ‘loxodromic midpoint’, the point half-way along a rhumb line
    between two points, is due to Robert Hill and Clive
    Tooth<sup><a href="http://mathforum.org/kb/message.jspa?messageID=148837">1</a></sup> (thx
    Axel!).</p>

<table>
    <tr>
        <td class="label">Formula: </td>
        <td class="formula">φ<sub>m</sub> = (φ<sub>1</sub>+φ<sub>2</sub>) / 2</td>
    </tr>
    <tr>
        <td></td>
        <td class="formula">f<sub>1</sub> = tan(π/4 + φ<sub>1</sub>/2)</td>
    </tr>
    <tr>
        <td></td>
        <td class="formula">f<sub>2</sub> = tan(π/4 + φ<sub>2</sub>/2)</td>
    </tr>
    <tr>
        <td></td>
        <td class="formula">f<sub>m</sub> = tan(π/4+φ<sub>m</sub>/2)</td>
    </tr>
    <tr>
        <td></td>
        <td class="formula">λ<sub>m</sub> = [ (λ<sub>2</sub>−λ<sub>1</sub>) ⋅ ln(f<sub>m</sub>) +
            λ<sub>1</sub> ⋅ ln(f<sub>2</sub>) − λ<sub>2</sub> ⋅ ln(f<sub>1</sub>) ] /
            ln(f<sub>2</sub>/f<sub>1</sub>)</td>
    </tr>
    <tr>
        <td class="label align-right">where</td>
        <td>φ <i>is latitude</i>, λ <i>is longitude</i>, ln <i>is natural log</i></td>
    </tr>
    <tr>
        <td class="label">JavaScript:<div class="small grey">(all angles <br>in radians)</div></td>
        <td>
            <pre class="code prettyprint>">
if (Math.abs(λ2-λ1) &gt; Math.PI) λ1 += 2*Math.PI; // crossing anti-meridian

var φ3 = (φ1+φ2)/2;
var f1 = Math.tan(Math.PI/4 + φ1/2);
var f2 = Math.tan(Math.PI/4 + φ2/2);
var f3 = Math.tan(Math.PI/4 + φ3/2);
var λ3 = ( (λ2-λ1)*Math.log(f3) + λ1*Math.log(f2) - λ2*Math.log(f1) ) / Math.log(f2/f1);

if (!isFinite(λ3)) λ3 = (λ1+λ2)/2; // parallel of latitude</pre>
        </td>
    </tr>
    <tr>
        <td></td>
        <td class="note">The longitude can be normalised to −180…+180 using <code>(lon+540)%360-180</code></td>
    </tr>
</table>
<hr>

<h3 id="using">Using the scripts in web pages</h3>

<p>Using these scripts in web pages would be something like the following:</p>
<pre class="prettyprint margin-l-1cm">
&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;title&gt;Using the scripts in web pages&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;script defer src=&quot;//cdn.rawgit.com/chrisveness/geodesy/v1.1.2/latlon-spherical.js&quot;&gt;&lt;/script&gt;
    &lt;script defer src=&quot;//cdn.rawgit.com/chrisveness/geodesy/v1.1.2/dms.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelector('#calc-dist').onclick = function() {
                const lat1 = document.querySelector('#lat1').value;
                const lon1 = document.querySelector('#lon1').value;
                const lat2 = document.querySelector('#lat2').value;
                const lon2 = document.querySelector('#lon2').value;
                const p1 = new LatLon(Dms.parseDMS(lat1), Dms.parseDMS(lon1));
                const p2 = new LatLon(Dms.parseDMS(lat2), Dms.parseDMS(lon2));
                const dist = parseFloat(p1.distanceTo(p2).toPrecision(4));
                document.querySelector('#result-distance').textContent = dist;
            }
        });
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form&gt;
        Lat 1: &lt;input type=&quot;text&quot; name=&quot;lat1&quot; id=&quot;lat1&quot;&gt;
        Lon 1: &lt;input type=&quot;text&quot; name=&quot;lon1&quot; id=&quot;lon1&quot;&gt;
        Lat 2: &lt;input type=&quot;text&quot; name=&quot;lat2&quot; id=&quot;lat2&quot;&gt;
        Lon 2: &lt;input type=&quot;text&quot; name=&quot;lon2&quot; id=&quot;lon2&quot;&gt;
        &lt;button type=&quot;button&quot; id=&quot;calc-dist&quot;&gt;Calculate distance&lt;/button&gt;
        &lt;output id=&quot;result-distance&quot;&gt;&lt;/output&gt; metres
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<hr>

<h3 id="convertDecDMS">Convert between degrees-minutes-seconds &amp; decimal degrees</h3>

<form name="convert" id="convert">
    <table class="note">
        <tr>
            <td>Latitude</td>
            <td>Longitude</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><input type="text" name="latD" id="latD" value="52.20472°N" class="note w8"></td>
            <td><input type="text" name="lonD" id="lonD" value="000.14056°E" class="note w8"></td>
            <td colspan="2">1° ≈ 111 km <span class="grey">(110.57 eq’l — 111.70 polar)</span></td>
        </tr>
        <tr>
            <td><input type="text" name="latDM" id="latDM" value="52°12.283′N" class="note w8"></td>
            <td><input type="text" name="lonDM" id="lonDM" value="000°08.433′E" class="note w8"></td>
            <td>1′ ≈ 1.85 km <span class="grey">(= 1 nm)</span></td>
            <td>0.01° ≈ 1.11 km</td>
        </tr>
        <tr>
            <td><input type="text" name="latDMS" id="latDMS" value="52°12′17.0″N" class="note w8"></td>
            <td><input type="text" name="lonDMS" id="lonDMS" value="000°08′26.0″E" class="note w8"></td>
            <td>1″ ≈ 30.9 m</td>
            <td>0.0001° ≈ 11.1 m</td>
        </tr>
    </table>
</form>

<form>Display calculation results as:
    <input type="radio" name="deg-format" id="deg-format-d" value="d"> <span title="decimal">degrees</span>
    <input type="radio" name="deg-format" id="deg-format-dm" value="dm"> <span title="sow’s ear">deg/min</span>
    <input type="radio" name="deg-format" id="deg-format-dms" value="dms"> <span title="sexagesimal">deg/min/sec</span>
</form>

<hr>

<p id="notes"><i>Notes:</i></p>
<ul class="note">
    <li id="ellipsoid">Accuracy: since the earth is not quite a sphere, there are small errors in
        using spherical geometry; the earth is actually roughly <b>ellipsoidal</b> (or more precisely,
        oblate spheroidal) with a radius varying between about 6,378km (equatorial) and 6,357km (polar),
        and local radius of curvature varying from 6,336km (equatorial meridian) to 6,399km (polar).
        6,371 km is the generally accepted value for the earth’s
        <a href="//en.wikipedia.org/wiki/Earth_radius#Mean_radius">mean radius</a>. This means that errors
        from assuming spherical geometry might be up to 0.55% crossing the equator, though generally
        below 0.3%, depending on latitude and direction of travel (<i>whuber</i> explores this in excellent
        detail on <a href="http://gis.stackexchange.com/questions/25494#25580">stackexchange</a>).
        An accuracy of better than 3m in 1km is mostly good enough for me, but if you want greater
        accuracy, you could use the <a href="latlong-vincenty.html">Vincenty</a> formula for
        calculating geodesic distances on ellipsoids, which gives results accurate to within 1mm.
        (Out of sheer perversity – I’ve never needed such accuracy – I looked up this formula and
        discovered the JavaScript implementation was simpler than I expected).</li>
    <li>Trig functions take arguments in <b>radians</b>, so latitude, longitude, and bearings in
        <b>degrees</b> (either decimal or degrees/minutes/seconds) need to be converted to radians,
        rad = π.deg/180. When converting radians back to degrees (deg = 180.rad/π), West is negative
        if using signed decimal degrees. For bearings, values in the range -π to +π [-180° to +180°]
        need to be converted to 0 to +2π [0°–360°]; this can  be done by (brng+2.π)%2.π [or
        brng+360)%360] where % is the (floating point) modulo operator (note that different languages
        implement the <a href="https://en.wikipedia.org/wiki/Modulo_operation">modulo operation</a>
        in different ways).</li>
    <li>All bearings are with respect to <b>true north</b>, 0°=N, 90°=E, etc; if you are working
        from a compass, magnetic north varies from true north in a complex way around the earth,
        and the difference has to be compensated for by variances indicated on local maps.</li>
    <li>The <b>atan2</b>() function widely used here takes two arguments, atan2(y, x), and computes
        the arc tangent of the ratio y/x. It is more flexible than atan(y/x), since it handles x=0,
        and it also returns values in all 4 quadrants -π to +π (the atan function returns values
        in the range -π/2 to +π/2).</li>
    <li>If you implement any formula involving atan2 in a spreadsheet (Microsoft <b>Excel</b>,
        LibreOffice Calc, Google Sheets, Apple Numbers), you will need to reverse  the arguments, as
        <a href="http://office.microsoft.com/en-gb/excel/HP052089911033.aspx">Excel</a> etc have them
        the opposite way around from <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Math/atan2">JavaScript</a>
        – conventional order is atan2(y, x), but Excel uses atan2(x, y). To use atan2 in a (VBA) macro,
        you can use WorksheetFunction.Atan2(). </li>
    <li>If you are using <b>Google Maps</b>, several of these functions are now provided in the Google
        Maps API V3 ‘spherical’ library (computeDistanceBetween(), computeHeading(), computeOffset(),
        interpolate(), etc; note they use a default Earth radius of 6,378,137 meters).</li>
    <li>If you use UK Ordnance Survey Grid References, I have implemented a script for
        <a href="latlong-os-gridref.html">converting between Lat/Long &amp; OS Grid References</a>.</li>
    <li>If you use UTM coordinates or MGRS grid references, I have implemented scripts for
        <a href="latlong-utm-mgrs.html">converting between Lat/Long, UTM, &amp; MGRS</a>.</li>
    <li>I learned a lot from the US Census Bureau <a href="gis-faq-5.1.html">GIS FAQ</a> which is no
        longer available, so I’ve made a copy.</li>
    <li>Thanks to Ed Williams’ <a href="http://www.edwilliams.org/avform.htm">Aviation Formulary</a>
        for many of the formulæ.</li>
    <li>For <b>miles</b>, divide km by 1.609344</li>
    <li>For <b>nautical miles</b>, divide km by 1.852</li>
</ul>

<hr class="fullwidth">

<p id="postscript">See below for the JavaScript source code,
    also available on <a href="https://github.com/chrisveness/geodesy/blob/master/latlon-spherical.js">GitHub</a>.
    Note I use Greek letters in variables representing maths symbols conventionally presented as Greek letters:
    I value the great benefit in legibility over the minor inconvenience in typing (if you
    encounter any problems, ensure your <code>&lt;head&gt;</code> includes <code>&lt;meta charset="utf-8"&gt;</code>).</p>
<p>With its untyped C-style syntax, JavaScript reads remarkably close to pseudo-code: exposing the
    algorithms with a minimum of syntactic distractions. These functions should be simple to
    translate into other languages if required, though can also be used as-is in browsers and Node.js.</p>
<p>I have extended the base JavaScript Number object with toRadians() and toDegrees() methods:
    I don’t see great likelihood of conflicts, as these are ubiquitous operations.</p>
<p>I also have a page illustrating the use of the spherical law of cosines for <a href="latlong-db.html">selecting
    points from a database</a> within a specified bounding circle – the example is based on MySQL+PDO,
    but should be extensible to other DBMS platforms.</p>
<p id="spreadsheets">Several people have asked about  example <b>Excel</b> spreadsheets, so I have implemented the
    <a href="latlong-distance+bearing.xls">distance &amp; bearing</a> and the <a href="latlong-dest-point.xls">destination
    point</a> formulæ as spreadsheets, in a form which breaks down the all stages involved to illustrate
    the operation.</p>
<p><i>January 2010</i>: I have revised the scripts to be structured as methods of a LatLon object.
    Of course, while JavaScript is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript">object-oriented</a>,
    it is a <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Details_of_the_Object_Model">prototype-based
    rather than class-based</a> language, so this is not actually a class, but isolating code into a separate namespace
    is good JavaScript practice.
    If you’re not familiar with JavaScript syntax, <code>LatLon.prototype.distanceTo = function(point)
    { ... }</code>, for instance, defines a ‘<code>distanceTo</code>’ method of the <code>LatLon</code> object
    (/class) which takes a <code>LatLon</code> object as a parameter (and returns a number). The
    <i>Dms</i> namespace acts as a static class for geodesy formatting / parsing / conversion functions.</p>
<p><i>January 2015</i>: I have refactored the scripts to inter-operate better, and rationalised certain aspects: the
    JavaScript file is now latlon-spherical.js instead of simply latlon.js; distances are now always in metres; the earth’s
    radius is now a parameter to distance calculation methods rather than to the constructor; the
    previous <code>Geo</code> object is now <code>Dms</code>, to better indicate its purpose; the
    <code>destinationPoint</code> function has the distance parameter before the bearing.</p>
<p>Performance: as noted above, the haversine distance calculation takes around
    <a href="performance/latlong-spherical.html">2 – 5 micro&shy;seconds</a> (hence around 200,000 –
    500,000 per second). I have yet to complete timing tests on other calculations.</p>
<p id="other-languages"><b>Other languages</b>: I cannot support translations into other languages, but if you have ported
    the code to another language, I am happy to provide links here.</p>
<ul>
    <li>Brian Lambert has made an <a href="https://github.com/softwarenerd/GreatCircle">Objective-C</a> version.</li>
    <li>Jean Brouwers has made a <a href="https://github.com/mrJean1/PyGeodesy">Python</a> version.</li>
</ul>
<p id="licence"><a href="http://opensource.org/licenses/MIT" class="float-right"><img src="license-osi-mit.png" alt="OSI MIT License"></a>
    I offer these scripts for free use and adaptation to balance my debt to the open-source info-verse.
    You are welcome to re-use these scripts [under an <a href="http://opensource.org/licenses/MIT">MIT</a> licence,
    without any warranty express or implied] provided solely that you retain my copyright notice and a link to this page.</p>
<p id="donate"><a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=3737803" class="float-right">
        <img alt="Paypal donation" style="margin:4px" src="https://www.paypal.com/en_GB/i/btn/btn_donate_SM.gif"></a>
    If you would like to show your appreciation and support continued development of these scripts,
    I would most gratefully accept <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&amp;hosted_button_id=3737803" title="Thank you!">donations</a>.</p>
<p>If you need any advice or development work done, I am available for consultancy.</p>
<p>If you have any queries or find any problems, contact me at <span class="rtl">ku.oc.epyt-elbavom@oeg-stpircs</span>.</p>
<p class="note"><i>© 2002-2017 Chris Veness</i></p>
</main>

<hr class="fullwidth">
<pre class="fullwidth code prettyprint" id="latlon-src"></pre>

<hr class="fullwidth">
<pre class="fullwidth code prettyprint" id="dms-src"></pre>

<!--[if lte IE 8]> <p>If IE8-, gets confused about line endings, you can view source at
    <a href="https://github.com/chrisveness/geodesy/blob/master/latlon.js">GitHub</a></p> <![endif]-->

<!-- 2012-10-07: phi, lambda for lat, lon -->
<!-- 2014-04-27: greek letters throughout, Gudermannian -->
<!-- 2014-06-27: rationalised script (all within listeners) -->
</body>
</html>
